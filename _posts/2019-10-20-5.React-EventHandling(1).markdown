---
layout: post
title:  "1020-[React]-5.React EventHandling (1)"
subtitle:   "1020-5.React EventHandling"
categories: devlog
tags: react
---

## React EventHandling (1)

<hr style="height: 1px; background: skyblue; "/>

#### 이벤트 (Event)
> - 사용자가 웹 브라우저에서 DOM 요소들과 상호 작용하는 것 

<hr style="height: 1px; background: skyblue; "/>

#### 이벤트 시스템
- 일반 html 에서 이벤트를 작성하는 것과 비슷하지만 , 주의 해야할 것들이 존재한다.

> 1. 이벤트 이름은 카멜 표기법 으로 작성
> 2. 이벤트에 실행할 자바스크립트 코드를 전달하는 것이 아니라, 함수 형태의 값을 전달
> 3. DOM 요소에만 이벤트를 설정 할수 있다.

<hr style="height: 1px; background: skyblue; "/>

#### 이벤트 종류
> - Clipboard 
> - Composition
> - KeyBoard
> - Focus
> - Form
> - Mouse
> - Selction
> - Touch
> - UI
> - Wheel
> - Media
> - Image
> - Animation
> - Transition

- 이 밖에도 많은 이벤트 가 있다
- http://facebook.github.io/react/docs/events.html 참고

<hr style="height: 1px; background: skyblue; "/>

#### EventPractice 렌더링

src/App.js

~~~

import React from 'react';

import EventPractice from './EventPractice';

const App = () => {


  return <EventPractice/>;

};

export default App;


~~~

src/EventPractice.js

~~~

import React , {Component} from 'react';

class EventPractice extends Component {
    render(){
        return(
            <div>
                <h1>이벤트연습</h1>
            </div>
        );
    }
}
export default EventPractice;

~~~

<img style="float: left;" src="https://user-images.githubusercontent.com/49095304/69969118-22508480-155f-11ea-9272-c53647119725.JPG" width="150"><br/><br/><br/><br/><br/>


<hr style="height: 1px; background: skyblue; "/>

#### onChange 이벤트 핸들링 하기

EventPractice.js

~~~

import React, { Component } from 'react';

class EventPractice extends Component {
    render() {
        return (
            <div>
                <h1>이벤트연습</h1>
                <input
                    type="text"
                    name="message"
                    placeholder="아무거나 입력하시오"
                    onChange={
                        (e) => {
                            console.log(e);
                        }
                    }
                />
            </div>
        );
    }
}
export default EventPractice;


~~~

<img style="float: left;" src="https://user-images.githubusercontent.com/49095304/69969600-15806080-1560-11ea-9763-8f26c20c324d.JPG" width="600"><br/><br/><br/><br/><br/>

- e 객체는 SyntheticEvent 로 웹 브라우저의 네이티브 이벤트를 감싸는 객체
- 네이티브 이벤트와 인터페이스가 같음
- 순수 자바스크립트에서 html 이벤트를 다룰때와 같이 사용


EventPractice.js

~~~

import React, { Component } from 'react';

class EventPractice extends Component {
    render() {
        return (
            <div>
                <h1>이벤트연습</h1>
                <input
                    type="text"
                    name="message"
                    placeholder="아무거나 입력하시오"
                    onChange={
                        (e) => {
                            console.log(e.target.value);
                        }
                    }
                />
            </div>
        );
    }
}
export default EventPractice;


~~~

<img style="float: left;" src="https://user-images.githubusercontent.com/49095304/69969749-5a0bfc00-1560-11ea-9ecc-ea99f77f86b7.JPG" width="600"><br/><br/><br/><br/><br/>
<br/><br/><br/><br/>

- 비동기적 이벤트 객체를 참조할 일이 있다면 e.persist() 함수 호출
- e.target.value  -> 값이 바뀔때마다 값을 콘솔에 기록

<hr style="height: 1px; background: skyblue; "/>


#### state에 input 값 담기

EventPractice.js

~~~

import React, { Component } from 'react';

class EventPractice extends Component {

    state = {
        message: ''
    }

    render() {
        return (
            <div>
                <h1>이벤트연습</h1>
                <input
                    type="text"
                    name="message"
                    placeholder="아무거나 입력하시오"
                    value={this.state.message}
                    onChange={
                        (e) => {
                            this.setState({
                                message: e.target.value
                            })
                        }
                    }
                />
            </div>
        );
    }
}
export default EventPractice;

~~~

- 입력값 state에 텍스트로 저장

<hr style="height: 1px; background: skyblue; "/>

#### 버튼 누를 때 comment 값을 공백으로 설정

EventPractice.js

~~~

import React, { Component } from 'react';

class EventPractice extends Component {

    state = {
        message: ''
    }

    render() {
        return (
            <div>
                <h1>이벤트연습</h1>
                <input
                    type="text"
                    name="message"
                    placeholder="아무거나 입력하시오"
                    value={this.state.message}
                    onChange={
                        (e) => {
                            this.setState({
                                message: e.target.value
                            })
                        }
                    }
                />
                <button onClick={
                    () => {
                        alert(this.state.message);
                        this.setState({
                            message: ''
                        });
                    }
                }>확인</button>
            </div>
        );
    }
}
export default EventPractice;

~~~

<img style="float: left;" src="https://user-images.githubusercontent.com/49095304/69970901-62fdcd00-1562-11ea-9b70-0b3bb004ab2e.JPG" width="600"><br/><br/><br/><br/><br/>
<br/><br/>

<hr style="height: 1px; background: skyblue; "/>

#### 임의 메서드 만들기

<strong>" 이벤트에 실행할 자바스크립트 코드를 전달하는 것이 아니라, 함수 형태의 값을 전달 "</strong>

> - 이벤트 처리할 때 렌더링 하는 동시에 함수를 만들어서 전달
> - 이 방법 대신 함수를 미리 준비하여 전달하는 방법도 있다.


- onClick 에 전달한 함수를 따로 빼내서 컴포넌트 임의 메서드 만들기

#### 기본 방식

EventPractice.js

~~~

import React, { Component } from 'react';

class EventPractice extends Component {

    state = {
        message: ''
    }
    constructor(props) {
        super(props);
        this.handleChange = this.handlChange.bind(this);
        this.handleClick = this.handleClick.bind(this);
    }

    handlChange(e) {
        this.setState({
                message: e.target.value
        });
    }
    handleClick() {
        alert(this.state.message);
        this.setState({
            message: ''
        });
    }

    render() {
        return (
            <div>
                <h1>이벤트연습</h1>
                <input
                    type="text"
                    name="message"
                    placeholder="아무거나 입력하시오"
                    value={this.state.message}
                    onChange={this.handlChange}
                />
                <button onClick={this.handleClick}>확인</button>
            </div>
        );
    }
}
export default EventPractice;

~~~

> - 함수가 호출 될때 this는 호출부에 따라 결정, 클래스의 임의 메서드가 특정 HTML 요소의 <br/>
>   이벤트로 등록되는 과정에서 메서드와 this의 관계가 끊김
> - 이 때문에 이벤트로 등록되어도 this를 컴포넌트 자신으로 제대로 가리키기 위해서는 <br/>
>   메서드를 this와 바인딩(binding)해야 함
> - 바인딩 하지 않으면 undefined 를 가리키게 됨

<hr style="height: 1px; background: skyblue; "/>

#### Property Initializer Syntax를 사용한 메서드

- 바벨의 transform-class-properties 문법을 사용하여 화살표 함수 형태로 메서드 정의

- 메서드 바인딩은 생성자 메서드에 하는 것이 정석 이나 이 작업이 조금 불편할수도 있다.
- 새 메서드를 만들때마다 constructor 수정해야하기 때문

EventPractice.js

~~~

import React, { Component } from 'react';

class EventPractice extends Component {

    state = {
        message: ''
    }
  
    handlChange = (e) => {
        this.setState({
             message: e.target.value
        });
    }
    handleClick = () => {
        alert(this.state.message);
        this.setState({
            message: ''
        });
    }

    render() {
        return (
            <div>
                <h1>이벤트연습</h1>
                <input
                    type="text"
                    name="message"
                    placeholder="아무거나 입력하시오"
                    value={this.state.message}
                    onChange={this.handlChange}
                />
                <button onClick={this.handleClick}>확인</button>
            </div>
        );
    }
}
export default EventPractice;

~~~

<hr style="height: 1px; background: skyblue; "/>

#### input 여러개 다루기

> - input 이 여러개 일때 event 객체를 활용
> - e.target.name
>   - onChange 핸들러에서 e.target.message 은 해당 인풋의 message자리

- render 함수에서 name 값이 username인 input을 렌더링, state 쪽에도 username 추가
- handleChange 변경

EventPractice.js

~~~

import React, { Component } from 'react';

class EventPractice extends Component {

    state = {
        username: '',
        message: ''
    }

    handlChange = (e) => {
        this.setState({
            [e.target.name]: e.target.value
        });
    }
    handleClick = () => {
        alert(this.state.username + " : " + this.state.message);
        this.setState({
            username: '',
            message: ''
        });
    }

    render() {
        return (
            <div>
                <h1>이벤트연습</h1>
                <input
                    type="text"
                    name="username"
                    placeholder="사용자"
                    value={this.state.username}
                    onChange={this.handlChange}
                />
                <input
                    type="text"
                    name="message"
                    placeholder="아무거나 입력하시오"
                    value={this.state.message}
                    onChange={this.handlChange}
                />
                <button onClick={this.handleClick}>확인</button>
            </div>
        );
    }
}
export default EventPractice;

~~~

<img style="float: left;" src="https://user-images.githubusercontent.com/49095304/69973269-93e00100-1566-11ea-9034-71ea974bfd15.JPG" width="600"><br/><br/><br/><br/><br/>
<br/><br/><br/><br/><br/><br/>

~~~

  handlChange = (e) => {
        this.setState({
            [e.target.name]: e.target.value
        });
    }

~~~

- 객체 안에서 key를 [] 로 감싸면 그 안에 넣은 레퍼런스가 가리키는 실제 값이 key 값으로 사용

~~~

const name ="variantKey";
const object =" {
    [name]: 'value'
};

================= result

{
    'variantKey': 'value'
}


~~~

<hr style="height: 1px; background: skyblue; "/>

#### onKeyPress 이벤트 핸들링

EventPractice.js 

~~~

import React, { Component } from 'react';

class EventPractice extends Component {

    state = {
        username: '',
        message: ''
    }

    handlChange = (e) => {
        this.setState({
            [e.target.name]: e.target.value
        });
    }
    handleClick = () => {
        alert(this.state.username + " : " + this.state.message);
        this.setState({
            username: '',
            message: ''
        });
    }

    handleKeyPress = (e) => {
        if(e.key === 'Enter') {
            this.handleClick();
        }
    }

    render() {
        return (
            <div>
                <h1>이벤트연습</h1>
                <input
                    type="text"
                    name="username"
                    placeholder="사용자"
                    value={this.state.username}
                    onChange={this.handlChange}
                />
                <input
                    type="text"
                    name="message"
                    placeholder="아무거나 입력하시오"
                    value={this.state.message}
                    onChange={this.handlChange}
                    onKeyPress={this.handleKeyPress}
                />
                <button onClick={this.handleClick}>확인</button>
            </div>
        );
    }
}
export default EventPractice;

~~~

- 엔터키 누르면 handleClick 메서드 실행


<hr style="height: 1px; background: skyblue; "/>

> 리액트를 다루는 기술 책을 보고 공부한 것을 정리하여 올린 글입니다.<br/>
> 출처: 길벗 리액트를 다루는 기술 <br/>






