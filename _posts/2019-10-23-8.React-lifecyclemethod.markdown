---
layout: post
title:  "1023-[React]-8.React lifecyclemethod"
subtitle:   "1023-8.React lifecyclemethod"
categories: devlog
tags: react
---

## React lifecycle method

<hr style="height: 1px; background: skyblue; "/>

> - 모든 리액트 컴포넌트에는 라이프 사이클이 존재 (수명 주기)
> - 컴포넌트의 수명은 페이지에 렌더링 되기 전인 준비 과정에서 시작하여 페이지에서 <br/>
>   사라질때 끝남
> - 컴포넌트 라이프 사이클 메서드를 사용하여 지정 해서 렌더링 가능
> - 라이프 사이클 메서드는 클래스형 컴포넌트에서만 사용 가능

<hr style="height: 1px; background: skyblue; "/>

#### 라이프 사이클 메서드 이해

- 라이프 사이클 메서드의 종류 9가지
> - Will 접두사
>   - 어떤 작업을 작동하기 전에 실행되는 메서드
> - Did 접두사
>   - 어떤 작업을 작동한 후 실행

- 이 메서드들은 컴포넌트 클래스에서 덮어 써 선언함으로써 사용할 수 있다.

- 라이프 사이클은 총 세가지
    - 즉 마운트, 업데이트, 언마운트
> - 리렌더링 : 컴포넌트 정보를 업데이트
> - 마운트 : 페이지에 컴포넌트가 나타남
> - 언마운트 : 페이지에서 컴포넌트가 사라짐


<img style="float: left;" src="https://user-images.githubusercontent.com/49095304/70526226-788b7c00-1b8c-11ea-8730-c4302292f43c.png" width="400"><br/><br/><br/>
<br/><br/><br/><br/><br/><br/><br/><br/><br/>

#### 마운트

- DOM 이 생성되고 웹브라우저상에서 나타나는 것을 마운트(Mount)

<img style="float: left;" src="https://user-images.githubusercontent.com/49095304/70526949-0c117c80-1b8e-11ea-94cf-0d1ae42311af.png" width="600"><br/><br/><br/>

- constructor : 컴포넌트를 새로 만들때마다 호출되는 클래스 생성자 메서드
- getDerivedStateFromProps: props 에 있는 값을 state에 넣을 때 사용하는 메서드
- render : 우리가 준비한 UI를 렌더링하는 메서드
- componentDidMount : 컴포넌트가 웹 브라우저상에서 나타난 후 호출하는 메서드

#### 업데이트

- props 가 바뀔때
- state 가 바뀔때
- 부모 컴포넌트가 리렌더링 될 때
- this.forceUpdate로 강제로 렌더링을 트리거 할때

<img style="float: left;" src="https://user-images.githubusercontent.com/49095304/70527404-357ed800-1b8f-11ea-85dd-bf39dc6debfa.png" width="800"><br/><br/><br/>
<br/><br/><br/>

> - 부모 컴포넌트에서 넘겨주는 props가 바귈때
>   - 컴포넌트에 전달하는 props의 값이 바뀌면 컴포넌트 렌더링 이루어진다
> - 컴포넌트 자신이 들고 있는 state가 setState를 통해 업데이트 될때
> - 부모 컴포넌트가 리렌더링
> - 자신에게 할당된 props가 바귀지 않아도, 또는 자신이 들고 이쓴 state가 바뀌지<br/>
>   않아도, 부모 컴포넌트가 리렌더링 되면 자식 컴포넌트 또한 리렌더링

- getDerivedStateFromProps : 마운트 과정에서도 호출, 업데이트 시작전 호출 <br/>
    props의 변화에 따라 state 값에도 변화를 주고 싶을때 사용
- shouldComponentUpdate : 컴포넌트가 리렌더링 해야 할지 말지 결정하는 메서드 <br/>
    true 혹은 false 를 반환 해야하며, true를 반환하면 다음 라이프사이클 실행 <br/>
    false를 반환하면 작업을 중지 <br/>
    - this.forceUpdate() 함수를 호출한다면 이과정 생략하고 바로 render함수 호출
- render: 컴포넌트를 리렌더링
- getSnapshotBeforeUpdate: 컴포넌트 변화를 DOM에 반영하기 바로직전에 호출하는 메서드
- componentUpdate: 컴포넌트의 업데이트 작업이 끝난 후 호출하는 메서드

#### 언마운트

- 마운트의 반대 과정, 즉 컴포넌트를 DOM에서 제거하는 것을 언마운트(unmount)

- componentWillUnmount : 컴포넌트가 웹 브라우저상에서 사라지기 전에 호출하는 메서드

<hr style="height: 1px; background: skyblue; "/>

#### 라이프 사이클 메서드 

1. render() 함수
2. constructor 메서드
3. getDerivedStateFromProps 메서드
4. componentDidMount 메서드
5. shouldComponentUpdate 메서드
6. getSnapshotBeforeUpdate 메서드
7. componentDidUpdate 메서드
8. componentWillMount 메서드
9. componentDidCatch 메서드


#### 라이프사이클 메서드 사용하기

- LifeCycleSample.js

~~~

import React , {Component} from 'react';

class LifeCycleSample extends Component {
    state = {
        number: 0,
        color: null,
    }

    myRef = null; // ref 설정 부분
    
    constructor(props) {
        super(props);
        console.log('constructor');
    }

    static getDerivedStateFromProps(nextProps, prevState) {
        console.log('getDerivedStateFromProps');
        if(nextProps.color !== prevState.color) {
            return { color: nextProps.color};   
        }
        return null;
    }

    componentDidMount() {
        console.log('componentDidMount');
    }

    shouldComponentUpdate(nextProps, nextState) {
        console.log('shouldComponentUpdate', nextProps , nextState);
        // 숫자의 마지막 자리가 4면 리렌더링하지 않습니다.
        return nextState.number % 10 !== 4;
    }

    componentWillUnmount() {
        console.log('componentWillMount');
    }

    handleClick = () => {
        this.setState({
            number: this.state.number + 1
        });
    }

    getSnapshotBeforeUpdate(prevProps, prevState) {
        console.log('getSnapshotBeforeUpdate');
        if(prevProps.color !== this.props.color) {
            return this.myRef.style.color;
        }
        return null;
    }

    componentDidUpdate(prevProps,prevState,snapshot){
        console.log('componentDidUpdate',prevProps,prevState);
        if(snapshot) {
            console.log('업데이트되기 직전 색상:',snapshot);
        }
    }

    render(){
        console.log('render');
    
        const style = {
            color: this.props.color
        }
        
        return (
            <div>
                <h1 style={style} ref={ref => this.myRef=ref}>
                    {this.state.number}
                </h1>
                <p>color: {this.state.color}</p>
                <button onClick={this.handleClick}>
                    더하기
                </button>
            </div>
        )
    }
}

export default LifeCycleSample;

~~~

- App.js

~~~

import React, { Component } from 'react';
import LifeCycleSample from './LifeCycleSample';

// 랜덤 색상을 생성합니다.
function getRandomColor() {
  return '#' + Math.floor(Math.random() * 16777215).toString(16);
}


class App extends Component {
  state = {
    color: '#000000'
  }

  handleClick = () => {
    this.setState({
      color: getRandomColor()
    });
  }
  render() {
    return (
      <div>
        <button onClick={this.handleClick}>랜덤 색상</button>
        <LifeCycleSample color={this.state.color} />
      </div>
    );
  }
}

export default App;


~~~

<hr style="height: 1px; background: skyblue; "/>

#### 에러 잡아내기 

- App.js


~~~

import React, { Component } from 'react';
import LifeCycleSample from './LifeCycleSample';
import ErrorBoundary from './ErrorBoundary';

// 랜덤 색상을 생성합니다.
function getRandomColor() {
  return '#' + Math.floor(Math.random() * 16777215).toString(16);
}


class App extends Component {
  state = {
    color: '#000000'
  }

  handleClick = () => {
    this.setState({
      color: getRandomColor()
    });
  }
  render() {
    return (
      <div>
        <button onClick={this.handleClick}>랜덤 색상</button>
        <ErrorBoundary>
        <LifeCycleSample color={this.state.color} />
        </ErrorBoundary>
      </div>
    );
  }
}

export default App;


~~~

- LifeCycleSample.js

~~~

import React , {Component} from 'react';

class LifeCycleSample extends Component {
    state = {
        number: 0,
        color: null,
    }

    myRef = null; // ref 설정 부분
    
    constructor(props) {
        super(props);
        console.log('constructor');
    }

    static getDerivedStateFromProps(nextProps, prevState) {
        console.log('getDerivedStateFromProps');
        if(nextProps.color !== prevState.color) {
            return { color: nextProps.color};   
        }
        return null;
    }

    componentDidMount() {
        console.log('componentDidMount');
    }

    shouldComponentUpdate(nextProps, nextState) {
        console.log('shouldComponentUpdate', nextProps , nextState);
        // 숫자의 마지막 자리가 4면 리렌더링하지 않습니다.
        return nextState.number % 10 !== 4;
    }

    componentWillUnmount() {
        console.log('componentWillMount');
    }

    handleClick = () => {
        this.setState({
            number: this.state.number + 1
        });
    }

    getSnapshotBeforeUpdate(prevProps, prevState) {
        console.log('getSnapshotBeforeUpdate');
        if(prevProps.color !== this.props.color) {
            return this.myRef.style.color;
        }
        return null;
    }

    componentDidUpdate(prevProps,prevState,snapshot){
        console.log('componentDidUpdate',prevProps,prevState);
        if(snapshot) {
            console.log('업데이트되기 직전 색상:',snapshot);
        }
    }

    render(){
        console.log('render');
    
        const style = {
            color: this.props.color
        }
        
        return (
            <div>
                {this.props.missing.value}
                <h1 style={style} ref={ref => this.myRef=ref}>
                    {this.state.number}
                </h1>
                <p>color: {this.state.color}</p>
                <button onClick={this.handleClick}>
                    더하기
                </button>
            </div>
        )
    }
}

export default LifeCycleSample;

~~~


- ErrorBoundary.js

~~~

import React, {Component} from 'react';

class ErrorBoundary extends Component {
    state = {
        error: false
    };

    componentDidCatch(error, info) {
        this.setState({
            error: true
        })
        console.log({error, info});
    }
    render() {
        if (this.state.error) return <div>에러가 발생했습니다.</div>;
        return this.props.children;
    }
}

export default ErrorBoundary;

~~~


<hr style="height: 1px; background: skyblue; "/>

> 리액트를 다루는 기술 책을 보고 공부한 것을 정리하여 올린 글입니다.<br/>
> 출처: 길벗 리액트를 다루는 기술 <br/>






