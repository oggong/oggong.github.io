---
layout: post
title:  "1101-[React]-17.React redux"
subtitle:   "1101-16.React redux"
categories: devlog
tags: react
---

## React redux

<hr style="height: 1px; background: skyblue; "/>

#### redux 개념 정의

- 리덕스는 가장 많이 사용하는 리액트 상태 관리 라이브러리
- 리덕스 를 사용하면 컴포넌트의 상태 업데이트 관련 로직을 다른 파일로 <br/>
    분리시켜서 더욱 효율적으로 관리 할  수 있다.
- 컴포넌트끼리 똑같은 상태를 공유해야 할 때도 여러 컴포넌트를 거치지 않고 <br/>
    손쉽게 상태 값을 전달하거나 업데이트 할수 있다.

- 리덕스 라이브러리는 전역 상태를 관리할 때 굉장히 효과적
- Context API를 통해서도 똑같은 작업을 할 수 있다.

- Context API 보다 더 큰 프로젝트를 사용할때 리덕스를 사용하는 것이 효율적

#### 액션

- 상태에 어떠한 변화가 필요하면 액션 이란것이 발생
- 하나의 객체로 표현된다

~~~

{
    type: 'TOGGLE_VALUE'
}

~~~

- 액션 객체는 type 필드를 반드시 가지고 있어야 함
- 이 값을 액션의 이름이라고 생각하면 된다.
- 그 외의 값들은 나중에 상태 업데이트를 할 때 상태 업데이트를 할 때 </br>
    참고해야 할 값이며, 작성자 마음대로 넣을 수 있다.

~~~

{
    type: 'ADD_TODO',
    data: {
        id: 1,
        text: '리덕스 배우기'

    }
}

{
    type: 'CHANGE_INPUT',
    text: '안녕하세요'
}


~~~

#### 액션 생성 함수

- 액션 생성 함수 (action creator)는 액션 객체를 만들어 주는 함수

~~~

function addTodo(data) {
    return {
        type: 'ADD_TODO',
        data
    };
}

// 화살표 함수로도 만들 수 있습니다.

const changeInput = text => ({
    type: 'CHANGE_INPUT',
    text
})

~~~

- 어떤 변화를 일으켜야 할 때마다 액션 객체를 만들어야 하는데 <br/>
    매번 액션 객체를 직접 작성하기 번거로울 수 있고, 만드는 과정에서 정보를<br/>
    놓칠수 있다.
- 이러한 일을 방지하기위해 함수로 만들어서 관리해야한다.

#### 리듀서

- 리듀서(reducer)는 변화를 일으키는 함수
- 액션을 만들어서 발생시키면 리듀서가 현재 상태와 전달받은 액션 객체를 <br/>
    파라미터로 받아 옵니다.
- 그리고 두 값을 참고하여 새로운 상태를 만들어서 반환

- 리듀서 코드

~~~

const initialState = {
    counter: 1
};

function reducer(state = initialState, action) {
    switch {action.type} {
        case INCREMENT:
            return {
                counter: state.counter + 1
            };
        default:
            return state;
    }
}

~~~

#### 스토어

- 프로젝트에 리덕스를 적용하기 위해 스토어(store)를 만든다
- 한 개의 프로젝트는 단 하나의 스토어만 가질 수 있다.
- 스토어 안에는 현재 애플리케이션 상태와 리듀서가 들어가 있으며, <br/>
    그 외에도 몇 가지 중요한 내장 함수를 지닌다.

#### 디스패치

- 디스패치는 스토어 내장 함수 중 하나
- 디스패치는 '액션을 발생시키는 것'
- 이 함수 dispatch(action)과 같은 형태로 액션 객체를 파라미터로 넣어서 호출
- 이 함수가 호출되면 스토어는 리듀서 함수를 실행시켜서 새로운 상태를 만들어줌

#### 구독

- 구독도 스토어의 내장 함수 중 하나
- subcribe 함수 안에 리스너 함수를 파라미터로 넣어서 호출해 주면, <br/>
    이 리스너 함수가 액션이 디스패치되어 상태가 업데이트 될 때마다 호출 된다

~~~

const listner = () => {
    console.log('상태가 업데이트됨');
}

const unsubcribe = store.subcrible(listner);

unsubcribe(); // 추후 구독을 비활성화할 때 함수를 호출

~~~

<hr style="height: 1px; background: skyblue; "/>

#### 리액트 없이 쓰는 리덕스

- 리덕스는 리액트에 종속되는 라이브러리 X

- 리액트에서 사용하려고 만들어졌지만 실제로 다른 UI 라이브러리/프레임워크와 사용가능
- 리덕스는 바닐라 자바스크립트와 함께 사용할 수도 있다.
- 바닐라 자바스크립트는 라이브러리나 프레임워크 없이 사용하는 순수 자바스크립트<br/>
    그 자체를 의미한다.

#### Parcel로 프로젝트 만들기

- 프로젝트 구성위해 Parcel이라는 도구 사용
- 아주 쉽고 빠르게 웹 애플리케이션 프로젝트를 구성할 수 있다.

- yarn global add parcel-bundler
    - npm install -g parcel-bundler 로 해도 된다.

- mkdir vanilla-redux
- cd vanilla-redux
- package.json 파일을 생성
- yarn init -y

- index.html

~~~

<html>

<body>
    <div>바닐라 자바스크립트</div>
    <script src="./index.js"></script>
</body>

</html>

~~~

- index.js

~~~

console.log('hello parcel');

~~~

- parcel index.html

- https://localhost:1234/ 으로 접속/ 결과 확인하기

#### 리덕스 모듈 설치

- yarn add redux

#### 간단한 UI 구성하기

- index.css

~~~

.toggle {
    border: 2px solid black;
    width: 64px;
    height: 64px;
    border-radius: 32px;
    box-sizing: border-box;
}

.toggle.active {
    background: yellow;
}

~~~

- index.html

~~~

<html>

    <head>
        <link rel="stylesheet" type="text/css" href="index.css" />
    </head>

    <body>
        <div class="toggle"></div>
        <hr />
        <h1>0</h1>
        <button id="increase">+1</button>
        <button id="decrease">-1</button>
        <script src="./index.js"></script>
    </body>

</html>

~~~


#### DOM 래퍼런스 만들기

- 별도 라이브러리 사용 하지 않아 DOM 직접 수정 해야 한다.

- index.js

~~~

const divToggle = document.querySelector('.toggle');
const counter = document.querySelector('h1');
const btnIncrease = document.querySelector('#increase');
const btnDecrease = document.querySelector('#decrease');


~~~

#### 액션 타입과 액션 생성 함수 정의

- 액션 이름 정의
    - 액션이름 문자열, 주로 대문자로 작성, 액션 이름은 중복이 되면 않됨

- index.js

~~~

const divToggle = document.querySelector('.toggle');
const counter = document.querySelector('h1');
const btnIncrease = document.querySelector('#increase');
const btnDecrease = document.querySelector('#decrease');

const TOGGLE_SWITCH = 'TOGGLE_SWITCH';
const INCREASE = 'INCREASE';
const DECREASE = 'DECREASE';


~~~

- 액션 객체를 만드는 액션 생성 함수 작성
    - 액션 객체는 type 값을 반드시 갖고 있어야 하며, 그외에 추후 상태를 <br/>
        업데이트할 때 참고하고 시픙ㄴ 값은 마음대로 넣을 수 있다.

- index.js

~~~

const divToggle = document.querySelector('.toggle');
const counter = document.querySelector('h1');
const btnIncrease = document.querySelector('#increase');
const btnDecrease = document.querySelector('#decrease');

const TOGGLE_SWITCH = 'TOGGLE_SWITCH';
const INCREASE = 'INCREASE';
const DECREASE = 'DECREASE';

const toggleSwitch = () => ({ type: TOGGLE_SWITCH});
const increase = difference => ({ type: INCREASE, difference});
const decrease = () => ({ type: DECREASE});

~~~

#### 초깃값 설정

- index.js

~~~

const divToggle = document.querySelector('.toggle');
const counter = document.querySelector('h1');
const btnIncrease = document.querySelector('#increase');
const btnDecrease = document.querySelector('#decrease');

const TOGGLE_SWITCH = 'TOGGLE_SWITCH';
const INCREASE = 'INCREASE';
const DECREASE = 'DECREASE';

const toggleSwitch = () => ({ type: TOGGLE_SWITCH});
const increase = difference => ({ type: INCREASE, difference});
const decrease = () => ({ type: DECREASE});

const initialState = {
    toggle: false,
    counter: 0
};



~~~

#### 리듀서 함수 정의

- 변화를 일으키는 함수
- 함수 파라미터로는 state 와 action값을 받아온다

- index.js

~~~

const divToggle = document.querySelector('.toggle');
const counter = document.querySelector('h1');
const btnIncrease = document.querySelector('#increase');
const btnDecrease = document.querySelector('#decrease');

const TOGGLE_SWITCH = 'TOGGLE_SWITCH';
const INCREASE = 'INCREASE';
const DECREASE = 'DECREASE';

const toggleSwitch = () => ({ type: TOGGLE_SWITCH });
const increase = difference => ({ type: INCREASE, difference });
const decrease = () => ({ type: DECREASE });

const initialState = {
    toggle: false,
    counter: 0
};

// state가 undefined일 때는 initialState를 기본값으로 사용

function reducer(state = initialState, action) {
    // action.type에 따라 다른 작업을 처리함
    switch (action.type) {
        case TOGGLE_SWITCH:
            return {
                ...state, // 불변성 유지를 해 주어야 합니다.
                toggle: !state.toggle
            };
        case INCREASE:
            return {
                ...state,
                counter: state.counter + action.difference
            };
        case DECREASE:
            return {
                ...state,
                counter: state.counter - 1
            };
        default:
            return state;

    }
}


~~~

> - 리듀서 함수가 맨 처음 호출될 때는 state 값이 undefined
> - 해당 값이 undefined로 주어졌을 때는 initialState를 기본값으로 <br/>
>    설정하기 위해 함수의 파라미터 쪽에 기본값이 설정되어 있다.
> - 리듀서에서는 상태의 불변성을 유지하면서 데이터에 변화를 일으켜 주어야 한다.
> - 이 작업을 할 때는 spread 연산자(...)를 사용하면 편하다
> - 단 객체의 구조 복합해지면 spread 연산자로 불변성 관리하기 번거롭다.
> - 객체의 구조가 복잡해지거나 배열도 함께 다루는 경우 immer 라이브러리를 사용하면
> <br/> 좀더 쉽게  리듀서 작성 할 수 있다.

#### 스토어 만들기

- index.js

~~~

import { createStore } from 'redux';

const divToggle = document.querySelector('.toggle');
const counter = document.querySelector('h1');
const btnIncrease = document.querySelector('#increase');
const btnDecrease = document.querySelector('#decrease');

const TOGGLE_SWITCH = 'TOGGLE_SWITCH';
const INCREASE = 'INCREASE';
const DECREASE = 'DECREASE';

const toggleSwitch = () => ({ type: TOGGLE_SWITCH });
const increase = difference => ({ type: INCREASE, difference });
const decrease = () => ({ type: DECREASE });

const initialState = {
    toggle: false,
    counter: 0
};

// state가 undefined일 때는 initialState를 기본값으로 사용

function reducer(state = initialState, action) {
    // action.type에 따라 다른 작업을 처리함
    switch (action.type) {
        case TOGGLE_SWITCH:
            return {
                ...state, // 불변성 유지를 해 주어야 합니다.
                toggle: !state.toggle
            };
        case INCREASE:
            return {
                ...state,
                counter: state.counter + action.difference
            };
        case DECREASE:
            return {
                ...state,
                counter: state.counter - 1
            };
        default:
            return state;

    }
}

const store = createStore(reducer);

~~~

- 스토어를 만들 때는 createStore 함수를 사용
- 이 함수를 사용하려면 코드 상단에 import 구문을 넣어 리덕스에서 <br/>
    해당 함수를 불러와야 하고, 함수의 파라미터에 리듀서 함수를 넣어 주어야한다.


#### render 함수 만들기

- 상태가 업데이트될 때마다 호출되며, 리액트의 render 함수와는 다르게 이미 <br/>
- html을 사용하여 UI의 속성을 상태에 따라 변경해 줍니다.

- index.js

~~~

import { createStore } from 'redux';

const divToggle = document.querySelector('.toggle');
const counter = document.querySelector('h1');
const btnIncrease = document.querySelector('#increase');
const btnDecrease = document.querySelector('#decrease');

const TOGGLE_SWITCH = 'TOGGLE_SWITCH';
const INCREASE = 'INCREASE';
const DECREASE = 'DECREASE';

const toggleSwitch = () => ({ type: TOGGLE_SWITCH });
const increase = difference => ({ type: INCREASE, difference });
const decrease = () => ({ type: DECREASE });

const initialState = {
    toggle: false,
    counter: 0
};

// state가 undefined일 때는 initialState를 기본값으로 사용

function reducer(state = initialState, action) {
    // action.type에 따라 다른 작업을 처리함
    switch (action.type) {
        case TOGGLE_SWITCH:
            return {
                ...state, // 불변성 유지를 해 주어야 합니다.
                toggle: !state.toggle
            };
        case INCREASE:
            return {
                ...state,
                counter: state.counter + action.difference
            };
        case DECREASE:
            return {
                ...state,
                counter: state.counter - 1
            };
        default:
            return state;

    }
}

const store = createStore(reducer);

const render = () => {
    const state = store.getState(); // 현재 상태를 불러옵니다.
    // 토글 처리
    if (state.toggle) {
        divToggle.classList.add('active');
    } else {
        divToggle.classList.remove('active');
    }
    // 카운터 처리
    counter.innerText = state.counter;
};

render();

~~~

#### 구독하기

- 스토어 상태가 바뀔 때마다 방금 만든 render 함수가 호출되도록 해 줄 것
- 이 작업은 스토어의 내장 함수 subcribe 사용하여 수행 할 수 있다.

-ex

~~~

const listner = () => {
    console.log('상태가 업데이트됨'); 
}
const unsubcribe = store.subcribe(listner);

unsubcribe(); // 추후 구독을 비활성화할 때 함수를 호출

~~~

- 직접적으로 subcribe 함수를 직접 사용 X
- 추후 리액트에서 직접 사용하지 않을 예정
- react-redux 라는 라이브러리가 이 작업을 대신 한다.


- index.js

~~~

import { createStore } from 'redux';

const divToggle = document.querySelector('.toggle');
const counter = document.querySelector('h1');
const btnIncrease = document.querySelector('#increase');
const btnDecrease = document.querySelector('#decrease');

const TOGGLE_SWITCH = 'TOGGLE_SWITCH';
const INCREASE = 'INCREASE';
const DECREASE = 'DECREASE';

const toggleSwitch = () => ({ type: TOGGLE_SWITCH });
const increase = difference => ({ type: INCREASE, difference });
const decrease = () => ({ type: DECREASE });

const initialState = {
    toggle: false,
    counter: 0
};

// state가 undefined일 때는 initialState를 기본값으로 사용

function reducer(state = initialState, action) {
    // action.type에 따라 다른 작업을 처리함
    switch (action.type) {
        case TOGGLE_SWITCH:
            return {
                ...state, // 불변성 유지를 해 주어야 합니다.
                toggle: !state.toggle
            };
        case INCREASE:
            return {
                ...state,
                counter: state.counter + action.difference
            };
        case DECREASE:
            return {
                ...state,
                counter: state.counter - 1
            };
        default:
            return state;

    }
}

const store = createStore(reducer);

const render = () => {
    const state = store.getState(); // 현재 상태를 불러옵니다.
    // 토글 처리
    if (state.toggle) {
        divToggle.classList.add('active');
    } else {
        divToggle.classList.remove('active');
    }
    // 카운터 처리
    counter.innerText = state.counter;
};

render();
store.subcribe(render);

~~~

#### 액션 발생시키기

- 액션을 발생시키는 것 = 디스패치
- 스토어의 내장 함수 dispatch를 사용
- 파라미터는 액션 객체를 넣어주면 된다.

- index.js

~~~

import { createStore } from 'redux';

const divToggle = document.querySelector('.toggle');
const counter = document.querySelector('h1');
const btnIncrease = document.querySelector('#increase');
const btnDecrease = document.querySelector('#decrease');

const TOGGLE_SWITCH = 'TOGGLE_SWITCH';
const INCREASE = 'INCREASE';
const DECREASE = 'DECREASE';

const toggleSwitch = () => ({ type: TOGGLE_SWITCH });
const increase = difference => ({ type: INCREASE, difference });
const decrease = () => ({ type: DECREASE });

const initialState = {
    toggle: false,
    counter: 0
};

// state가 undefined일 때는 initialState를 기본값으로 사용

function reducer(state = initialState, action) {
    // action.type에 따라 다른 작업을 처리함
    switch (action.type) {
        case TOGGLE_SWITCH:
            return {
                ...state, // 불변성 유지를 해 주어야 합니다.
                toggle: !state.toggle
            };
        case INCREASE:
            return {
                ...state,
                counter: state.counter + action.difference
            };
        case DECREASE:
            return {
                ...state,
                counter: state.counter - 1
            };
        default:
            return state;

    }
}

const store = createStore(reducer);

const render = () => {
    const state = store.getState(); // 현재 상태를 불러옵니다.
    // 토글 처리
    if (state.toggle) {
        divToggle.classList.add('active');
    } else {
        divToggle.classList.remove('active');
    }
    // 카운터 처리
    counter.innerText = state.counter;
};

render();
store.subcribe(render);

divToggle.onClick = () => {
    store.dispatch(toggleSwitch());
};
divToggle.onClick = () => {
    store.dispatch(increase(1));
};
divToggle.onClick = () => {
    store.dispatch(decrease());
};

~~~

<hr style="height: 1px; background: skyblue; "/>

#### 리덕스의 세가지 규칙

- 단일 스토어

- 읽기 전용 상태

- 리듀서는 순수한 함수



<hr style="height: 1px; background: skyblue; "/>

> 리액트를 다루는 기술 책을 보고 공부한 것을 정리하여 올린 글입니다.<br/>
> 출처: 길벗 리액트를 다루는 기술 <br/>






